## 协程小项目的介绍和流程：协程coroutine

**项目描述**：
此项目是基于 Linux ucontext 族函数实现的简易协程库；
通过对协程的理解以及对ucontext函数族getcontext()，setcontext()，makecontext()，swapcontext()的简单使用；
实现了协程的创建，协程的挂起以及协程的唤醒；主要功能是协程的切换。


**介绍流程**：
此项目是基于 Linux ucontext 函数族实现的 简易的、非对称的 协程库；
ucontext 函数族主要有 ucontext_t 结构体 以及 几个函数；
ucontext_t 结构体是用来存放当前上下文环境的（后继上下文，栈的信息）。
由于协程的切换需要保存上下文信息嘛，其实不只是协程，线程，进程的切换也需要保存上下文信息；
只不过是操作系统帮我们解决了，而协程是用户及线程，需要我们手动的进行上下文信息的设置。

----------------------------------------------------------------------------------

**协程的上下文切换需要借助下面几个函数，ucontext函数族，下面是几个函数**：

```C++
int getcontext(ucontext_t* ucp)；
将当前程序的上下文信息保存到 ucp 中；
```

```C++
int setcontext(const ucontext_t *ucp)；
将ucontext_t结构体变量ucp中的上下文信息重新恢复到cpu中并执行；
```

```C++
void makecontext(ucontext_t *ucp, void (*func)(), int argc, ...)
修改上下文信息，参数ucp就是我们要修改的上下文信息结构体；func是上下文的入口函数；
argc是入口函数的参数个数，后面的…是具体的入口函数参数，该参数必须为整形值。
```

```C++
int swapcontext(ucontext_t *oucp, ucontext_t *ucp)
功能：将当前cpu中的上下文信息保存带oucp结构体变量中，然后将ucp中的结构体的上下文信息恢复到cpu中。
这里可以理解为调用了两个函数，第一次是调用了getcontext(oucp)然后再调用setcontext(ucp)。
```

----------------------------------------------------------------------------------

**在使用方面**，主要就是 创建协程，唤醒协程，挂起协程；
因为是对称的协程库，所以当协程挂起的时候，程序会返回到调度器保存的一个上下文环境中（在这里相当于回到了主函数）。

----------------------------------------------------------------------------------

**在具体项目的架构设计方面**，所以我设计了两个类，一个是协程体类，一个是调度器类：

**协程类里面**：
主要有（当前协程的上下文，协程的具体函数，以及函数的参数，协程的状态，和栈信息）

**调度器类**：
调度器类用于管理所有的协程，里面主要有一个协程类的数组，以及主协程的上下文，用于协程挂起时切回主程序；
除此之外还有就是 当前正在运行的协程的编号。
然后协程的操作，都是通过这个调度器来控制的。

----------------------------------------------------------------------------------

**一些主要的函数有**：

**协程的创建：uthread_create**
在调度器里面的协程池里面找到一个空位置；
	然后设置一下这个协程的部分参数（函数，以及函数的参数等）
	这里并没有直接就执行协程。


**协程的挂起：uthread_yield**
  将当前协程挂起，回到主协程中；
	通过 swapcontext(&(t->ctx),&(schedule.main));
	保存上下文到 t->ctx，切换到主协程


**协程的唤醒：uthread_resume**
	这个就稍微复杂了一点：
	判断协程是否是第一次唤醒（协程是 就绪，还是 挂起状态）
	如果是挂起状态（不是第一次唤醒）
		则直接切换到协程的上下文就行；
	如果是就绪状态（第一次唤醒）
		由于我们在创建的时候并没有设置上下文信息；
		所以在这里我们需要设置一下上下文信息（栈空间，栈空间大小，设置后继上下文）；
		并设置协程的入口函数makecontext(&(t->ctx),(void (*)(void))(uthread_body),1,&schedule);
		接着切换到协程的上下文就行。

**还有一些辅助函数**：

// 判断schedule中所有的协程是否都执行完毕，是返回1，否则返回0
int schedule_finished(const schedule_t &schedule);

// 协程执行的入口函数
static void uthread_body(schedule_t *ps);

----------------------------------------------------------------------------------

**改进**：
	由于我们在创建协程的时候是在协程数组里面找一个空闲的位置分给协程；
	这样的话时间复杂度就比较高；
	我们可以参考LRU的改进算法；
	维护两条协程链表，一条是创建好的协程（活跃链表），一条是空闲链表；
	（当然这里还需要对 协程的编号 以及 协程体这个节点 做一个双向映射）
	
	当我们创建协程的时候，直接在空闲链表里面取一个空闲节点；
	初始化 并 加入到第一条链表就行；
	
	当协程运行完成，我们就将它从第一条链表中删除，然后将这个节点加入空闲链表就行；

	这样的时间复杂度会降低很多，由于需要对 协程号 和 协程体节点 做映射；
	这里我考虑是用map，所以时间复杂度是O（logn）的；
	当然用unordered_map的话，平均时间复杂应该是O（1）的。







